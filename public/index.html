<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real Voice Call - WebRTC</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      max-width: 500px;
      width: 100%;
      text-align: center;
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 1.8rem;
    }
    
    .subtitle { 
      color: #666; 
      margin-bottom: 25px;
      font-size: 1rem;
    }
    
    .name-section {
      margin-bottom: 20px;
      text-align: left;
    }
    
    .name-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }
    
    .name-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      outline: none;
      margin-bottom: 15px;
    }
    
    .name-input:focus {
      border-color: #667eea;
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 25px;
    }
    
    button {
      padding: 15px 25px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      min-height: 50px;
    }
    
    .create-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }
    
    .create-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    }
    
    .join-section { 
      display: flex; 
      flex-direction: column;
      gap: 10px; 
    }
    
    @media (min-width: 480px) {
      .join-section {
        flex-direction: row;
      }
    }
    
    input {
      flex: 1;
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      outline: none;
      min-height: 50px;
    }
    
    input:focus { border-color: #667eea; }
    
    .join-btn { 
      background: #2ecc71; 
      color: white; 
      min-width: 120px;
    }
    .join-btn:hover { background: #27ae60; }
    
    .room-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      display: none;
    }
    
    .call-controls { 
      margin-top: 20px; 
      display: none;
      text-align: center;
    }
    
    .call-status {
      padding: 15px;
      background: #fff3cd;
      color: #856404;
      border-radius: 10px;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .call-status.connected {
      background: #d4edda;
      color: #155724;
    }
    
    .users-list {
      margin-top: 15px;
      text-align: left;
    }
    
    .user-item {
      padding: 10px 15px;
      margin: 8px 0;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea, #764ba2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }
    
    .user-name {
      font-weight: 600;
      color: #333;
    }
    
    .user-you {
      border-left-color: #2ecc71;
      background: #f8fff9;
    }
    
    .user-audio-status {
      margin-left: auto;
      font-size: 12px;
      padding: 4px 8px;
      border-radius: 12px;
      background: #f8f9fa;
    }
    
    .user-audio-connected {
      background: #d4edda;
      color: #155724;
    }
    
    .debug-info {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 12px;
      color: #666;
      text-align: left;
      max-height: 150px;
      overflow-y: auto;
    }
    
    .control-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .mute-btn, .leave-btn, .retry-btn {
      padding: 12px 20px;
      font-size: 16px;
      border-radius: 25px;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 120px;
    }
    
    .mute-btn {
      background: #6c757d;
      color: white;
    }
    
    .mute-btn.muted {
      background: #e74c3c;
    }
    
    .leave-btn {
      background: #dc3545;
      color: white;
    }
    
    .retry-btn {
      background: #fd7e14;
      color: white;
    }
    
    .user-count { 
      font-weight: bold; 
      color: #667eea;
      font-size: 1.1rem;
    }
    
    .your-name {
      background: #667eea;
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      display: inline-block;
      margin: 10px 0;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¤ Real Voice Call</h1>
    <p class="subtitle">Create a room and start talking with WebRTC</p>
    
    <div class="name-section">
      <label class="name-label" for="userNameInput">Your Name:</label>
      <input type="text" id="userNameInput" class="name-input" placeholder="Enter your name" maxlength="20" value="">
    </div>
    
    <div class="button-group" id="setup">
      <button class="create-btn" onclick="createRoom()">Create New Room</button>
      <div class="join-section">
        <input type="text" id="roomInput" placeholder="Enter Room ID">
        <button class="join-btn" onclick="joinRoom()">Join Room</button>
      </div>
    </div>
    
    <div class="room-info" id="roomInfo">
      <h3>Room: <span id="roomIdDisplay"></span></h3>
      <div class="your-name">You are: <span id="userNameDisplay"></span></div>
      <p>Users in call: <span class="user-count" id="userCount">1</span></p>
      
      <div class="users-list" id="usersList">
        <!-- Users will be added here dynamically -->
      </div>
      
      <div class="debug-info" id="debugInfo">
        Connection status: Waiting...
      </div>
    </div>
    
    <div class="call-controls" id="callControls">
      <div class="call-status" id="callStatus">
        ðŸŽ¤ Setting up voice call...
      </div>
      
      <div class="control-buttons">
        <button class="mute-btn" id="muteButton" onclick="toggleMute()">
          ðŸ”‡ Mute
        </button>
        <button class="retry-btn" onclick="retryConnections()">
          ðŸ”„ Retry Connections
        </button>
        <button class="leave-btn" onclick="leaveRoom()">
          ðŸ“ž Leave Call
        </button>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let localStream = null;
    let currentRoom = null;
    let isMuted = false;
    const peers = {};
    const remoteAudioElements = {};
    const userConnections = new Map(); // Track connection states
    
    // Enhanced ICE servers configuration
    const config = { 
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'stun:stun2.l.google.com:19302' },
        { urls: 'stun:stun3.l.google.com:19302' },
        { urls: 'stun:stun4.l.google.com:19302' }
      ],
      iceCandidatePoolSize: 10,
      bundlePolicy: 'max-bundle',
      rtcpMuxPolicy: 'require'
    };

    // Debug logging
    function addDebug(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();
      debugInfo.innerHTML += `<div>[${timestamp}] ${message}</div>`;
      debugInfo.scrollTop = debugInfo.scrollHeight;
      console.log(message);
    }

    // Check for room ID in URL
    const urlParams = new URLSearchParams(window.location.search);
    const roomFromUrl = urlParams.get('room');
    if (roomFromUrl) {
      document.getElementById('roomInput').value = roomFromUrl;
    }

    function getUserName() {
      const userNameInput = document.getElementById('userNameInput');
      return userNameInput.value.trim() || 'Anonymous';
    }

    function createRoom() {
      const userName = getUserName();
      addDebug('Creating room...');
      socket.emit('create-room', { userName });
    }

    function joinRoom() {
      const roomId = document.getElementById('roomInput').value.trim();
      const userName = getUserName();
      
      if (roomId) {
        addDebug('Joining room: ' + roomId);
        socket.emit('join-room', { roomId, userName });
      } else {
        alert('Please enter a room ID');
      }
    }

    function leaveRoom() {
      if (currentRoom) {
        addDebug('Leaving room...');
        socket.emit('leave-room', currentRoom);
        cleanup();
        resetUI();
      }
    }

    function retryConnections() {
      addDebug('Retrying all connections...');
      Object.keys(peers).forEach(peerId => {
        if (peers[peerId].connectionState !== 'connected') {
          addDebug(`Retrying connection to: ${peerId}`);
          createOffer(peerId);
        }
      });
    }

    function toggleMute() {
      if (!localStream) return;
      
      isMuted = !isMuted;
      const muteButton = document.getElementById('muteButton');
      
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      
      if (isMuted) {
        muteButton.textContent = 'ðŸ”Š Unmute';
        muteButton.classList.add('muted');
        addDebug('Microphone muted');
      } else {
        muteButton.textContent = 'ðŸ”‡ Mute';
        muteButton.classList.remove('muted');
        addDebug('Microphone unmuted');
      }
    }

    async function setupLocalStream() {
      try {
        addDebug('Requesting microphone access...');
        
        // Stop existing stream if any
        if (localStream) {
          localStream.getTracks().forEach(track => track.stop());
        }
        
        localStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true,
            channelCount: 1,
            sampleRate: 48000
          },
          video: false
        });
        
        addDebug('âœ… Microphone access granted - Stream active');
        
        // Update UI to show we have microphone
        document.getElementById('callStatus').textContent = 'âœ… Microphone ready - Connecting...';
        document.getElementById('callStatus').className = 'call-status';
        
        return true;
      } catch (error) {
        addDebug('âŒ Error accessing microphone: ' + error.message);
        alert('Cannot access microphone. Please check permissions and try again.');
        return false;
      }
    }

    function createPeerConnection(remoteId, userName) {
      if (peers[remoteId] && peers[remoteId].connectionState === 'connected') {
        addDebug(`Peer connection already connected to: ${userName}`);
        return peers[remoteId];
      }

      // Close existing connection if it exists but isn't connected
      if (peers[remoteId]) {
        peers[remoteId].close();
        delete peers[remoteId];
      }

      addDebug(`Creating peer connection for: ${userName} (${remoteId})`);
      const pc = new RTCPeerConnection(config);

      // Track connection state
      userConnections.set(remoteId, { connected: false, userName: userName });

      // Add local tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          const sender = pc.addTrack(track, localStream);
          addDebug(`Added ${track.kind} track to ${userName}`);
        });
      } else {
        addDebug('âš ï¸ No local stream available when creating peer connection');
      }

      // Create and setup audio element for remote stream
      let audioElement = remoteAudioElements[remoteId];
      if (!audioElement) {
        audioElement = document.createElement('audio');
        audioElement.autoplay = true;
        audioElement.playsInline = true;
        audioElement.controls = false;
        audioElement.style.display = 'none';
        audioElement.setAttribute('muted', 'false');
        remoteAudioElements[remoteId] = audioElement;
        document.body.appendChild(audioElement);
        
        // Force play to handle autoplay restrictions
        audioElement.play().catch(e => {
          addDebug(`Autoplay prevented for ${userName}, user interaction required`);
        });
      }

      // Handle incoming tracks
      pc.ontrack = (event) => {
        addDebug(`ðŸ“ž Received remote track from: ${userName}`);
        if (event.streams && event.streams[0]) {
          audioElement.srcObject = event.streams[0];
          addDebug(`âœ… Audio stream attached for: ${userName}`);
          
          // Update UI to show audio is connected
          updateUserAudioStatus(remoteId, true);
        }
      };

      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-ice-candidate', {
            to: remoteId,
            candidate: event.candidate
          });
        } else {
          addDebug(`âœ… ICE gathering complete for: ${userName}`);
        }
      };

      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        const state = pc.connectionState;
        addDebug(`ðŸ”— ${userName} connection state: ${state}`);
        
        if (state === 'connected') {
          userConnections.set(remoteId, { connected: true, userName: userName });
          updateUserAudioStatus(remoteId, true);
          updateOverallConnectionStatus();
        } else if (state === 'disconnected' || state === 'failed') {
          userConnections.set(remoteId, { connected: false, userName: userName });
          updateUserAudioStatus(remoteId, false);
          updateOverallConnectionStatus();
          
          // Try to reconnect after 3 seconds if failed
          if (state === 'failed') {
            setTimeout(() => {
              if (currentRoom && peers[remoteId] && peers[remoteId].connectionState !== 'connected') {
                addDebug(`ðŸ”„ Attempting to reconnect to: ${userName}`);
                createOffer(remoteId);
              }
            }, 3000);
          }
        }
      };

      // Handle ICE connection state
      pc.oniceconnectionstatechange = () => {
        addDebug(`ðŸ§Š ${userName} ICE state: ${pc.iceConnectionState}`);
      };

      peers[remoteId] = pc;
      return pc;
    }

    async function createOffer(remoteId) {
      const userName = userConnections.get(remoteId)?.userName || remoteId;
      
      // Ensure we have local stream first
      if (!localStream) {
        const success = await setupLocalStream();
        if (!success) {
          addDebug('âŒ Cannot create offer without microphone access');
          return;
        }
      }

      const pc = createPeerConnection(remoteId, userName);
      
      try {
        addDebug(`Creating offer for: ${userName}`);
        
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: false
        });
        
        await pc.setLocalDescription(offer);
        
        socket.emit('webrtc-offer', {
          to: remoteId,
          sdp: pc.localDescription
        });
        
        addDebug(`âœ… Offer sent to: ${userName}`);
      } catch (error) {
        addDebug(`âŒ Error creating offer for ${userName}: ${error.message}`);
      }
    }

    async function handleOffer(from, sdp) {
      const userName = userConnections.get(from)?.userName || from;
      addDebug(`Received offer from: ${userName}`);
      
      // Ensure we have local stream first
      if (!localStream) {
        const success = await setupLocalStream();
        if (!success) {
          addDebug('âŒ Cannot handle offer without microphone access');
          return;
        }
      }

      const pc = createPeerConnection(from, userName);
      
      try {
        await pc.setRemoteDescription(sdp);
        addDebug(`âœ… Remote description set for: ${userName}`);
        
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        
        socket.emit('webrtc-answer', {
          to: from,
          sdp: pc.localDescription
        });
        
        addDebug(`âœ… Answer sent to: ${userName}`);
      } catch (error) {
        addDebug(`âŒ Error handling offer from ${userName}: ${error.message}`);
      }
    }

    async function handleAnswer(from, sdp) {
      const userName = userConnections.get(from)?.userName || from;
      addDebug(`Received answer from: ${userName}`);
      const pc = peers[from];
      
      if (pc) {
        try {
          await pc.setRemoteDescription(sdp);
          addDebug(`âœ… Remote description set from answer for: ${userName}`);
        } catch (error) {
          addDebug(`âŒ Error handling answer from ${userName}: ${error.message}`);
        }
      } else {
        addDebug(`âŒ No peer connection found for: ${userName}`);
      }
    }

    async function handleIceCandidate(from, candidate) {
      const userName = userConnections.get(from)?.userName || from;
      const pc = peers[from];
      
      if (pc) {
        try {
          await pc.addIceCandidate(candidate);
          addDebug(`âœ… ICE candidate added for: ${userName}`);
        } catch (error) {
          addDebug(`âŒ Error adding ICE candidate for ${userName}: ${error.message}`);
        }
      }
    }

    function updateUserAudioStatus(userId, isConnected) {
      const userElement = document.getElementById(`user-${userId}`);
      if (userElement) {
        let statusElement = userElement.querySelector('.user-audio-status');
        if (!statusElement) {
          statusElement = document.createElement('div');
          statusElement.className = 'user-audio-status';
          userElement.appendChild(statusElement);
        }
        
        if (isConnected) {
          statusElement.textContent = 'ðŸ”Š Connected';
          statusElement.className = 'user-audio-status user-audio-connected';
        } else {
          statusElement.textContent = 'ðŸ”‡ Connecting...';
          statusElement.className = 'user-audio-status';
        }
      }
    }

    function updateOverallConnectionStatus() {
      const connectedCount = Array.from(userConnections.values()).filter(conn => conn.connected).length;
      const totalCount = userConnections.size;
      
      if (totalCount > 0) {
        const callStatus = document.getElementById('callStatus');
        if (connectedCount === totalCount) {
          callStatus.textContent = `âœ… All connections working (${connectedCount}/${totalCount})`;
          callStatus.className = 'call-status connected';
        } else {
          callStatus.textContent = `ðŸ”„ Connecting... (${connectedCount}/${totalCount} users)`;
          callStatus.className = 'call-status';
        }
      }
    }

    function cleanup() {
      // Close all peer connections
      Object.keys(peers).forEach(peerId => {
        if (peers[peerId]) {
          peers[peerId].close();
        }
        delete peers[peerId];
      });

      // Remove all audio elements
      Object.keys(remoteAudioElements).forEach(audioId => {
        if (remoteAudioElements[audioId].parentNode) {
          remoteAudioElements[audioId].parentNode.removeChild(remoteAudioElements[audioId]);
        }
        delete remoteAudioElements[audioId];
      });

      // Clear connection tracking
      userConnections.clear();

      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      addDebug('ðŸ§¹ Cleaned up all connections');
    }

    // Socket event handlers
    socket.on('room-created', async (data) => {
      currentRoom = data.roomId;
      addDebug('âœ… Room created: ' + data.roomId);
      showRoomInfo(data.roomId, data.userName);
      
      // Setup local stream immediately
      await setupLocalStream();
    });

    socket.on('room-joined', async (data) => {
      currentRoom = data.roomId;
      addDebug(`âœ… Room joined: ${data.roomId} with ${data.users.length} users`);
      showRoomInfo(data.roomId, data.userName);
      updateUsersList(data.users);
      
      // Setup local stream
      await setupLocalStream();
      
      // Create offers to all existing users with delay to ensure stream is ready
      data.users.forEach((user, index) => {
        if (user.id !== socket.id) {
          userConnections.set(user.id, { connected: false, userName: user.name });
          setTimeout(() => createOffer(user.id), 1000 + (index * 500)); // Stagger connections
        }
      });
    });

    socket.on('user-joined', (data) => {
      addDebug(`ðŸ‘¤ User joined: ${data.userName}`);
      addUserToList(data.userId, data.userName, false);
      updateUserCount();
      
      // Track the new user
      userConnections.set(data.userId, { connected: false, userName: data.userName });
      
      // Create offer to the new user after a delay
      if (localStream) {
        setTimeout(() => createOffer(data.userId), 1000);
      }
    });

    socket.on('user-left', (data) => {
      addDebug(`ðŸ‘¤ User left: ${data.userName}`);
      removeUserFromList(data.userId);
      updateUserCount();
      
      // Clean up
      userConnections.delete(data.userId);
      if (peers[data.userId]) {
        peers[data.userId].close();
        delete peers[data.userId];
      }
      if (remoteAudioElements[data.userId]) {
        if (remoteAudioElements[data.userId].parentNode) {
          remoteAudioElements[data.userId].parentNode.removeChild(remoteAudioElements[data.userId]);
        }
        delete remoteAudioElements[data.userId];
      }
      
      updateOverallConnectionStatus();
    });

    // WebRTC signaling
    socket.on('webrtc-offer', (data) => {
      handleOffer(data.from, data.sdp);
    });

    socket.on('webrtc-answer', (data) => {
      handleAnswer(data.from, data.sdp);
    });

    socket.on('webrtc-ice-candidate', (data) => {
      handleIceCandidate(data.from, data.candidate);
    });

    socket.on('error', (data) => {
      addDebug('âŒ Error: ' + data.message);
      alert('Error: ' + data.message);
    });

    function showRoomInfo(roomId, userName) {
      document.getElementById('setup').style.display = 'none';
      document.getElementById('roomInfo').style.display = 'block';
      document.getElementById('callControls').style.display = 'block';
      
      document.getElementById('roomIdDisplay').textContent = roomId;
      document.getElementById('userNameDisplay').textContent = userName;
    }

    function updateUsersList(users) {
      const usersList = document.getElementById('usersList');
      usersList.innerHTML = '';
      
      users.forEach(user => {
        const isCurrentUser = user.id === socket.id;
        addUserToList(user.id, user.name, isCurrentUser);
        
        // Track all users
        if (!isCurrentUser) {
          userConnections.set(user.id, { connected: false, userName: user.name });
        }
      });
      updateUserCount();
    }

    function addUserToList(userId, userName, isCurrentUser) {
      const usersList = document.getElementById('usersList');
      const userItem = document.createElement('div');
      userItem.className = 'user-item ' + (isCurrentUser ? 'user-you' : '');
      userItem.id = 'user-' + userId;
      
      const avatar = document.createElement('div');
      avatar.className = 'user-avatar';
      avatar.textContent = userName.charAt(0).toUpperCase();
      
      const name = document.createElement('div');
      name.className = 'user-name';
      name.textContent = userName + (isCurrentUser ? ' (You)' : '');
      
      userItem.appendChild(avatar);
      userItem.appendChild(name);
      usersList.appendChild(userItem);
      
      // Add connection status for remote users
      if (!isCurrentUser) {
        updateUserAudioStatus(userId, false);
      }
    }

    function removeUserFromList(userId) {
      const userElement = document.getElementById('user-' + userId);
      if (userElement) {
        userElement.remove();
      }
    }

    function updateUserCount() {
      const userItems = document.querySelectorAll('.user-item');
      document.getElementById('userCount').textContent = userItems.length;
    }

    function resetUI() {
      document.getElementById('setup').style.display = 'block';
      document.getElementById('roomInfo').style.display = 'none';
      document.getElementById('callControls').style.display = 'none';
      currentRoom = null;
      document.getElementById('debugInfo').innerHTML = 'Connection status: Waiting...';
    }

    window.addEventListener('beforeunload', () => {
      if (currentRoom) {
        socket.emit('leave-room', currentRoom);
      }
    });

    // Focus on name input when page loads
    window.addEventListener('load', () => {
      document.getElementById('userNameInput').focus();
    });
  </script>
</body>
</html>
