<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real Voice Call - WebRTC</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    
    .container {
      background: white;
      padding: 30px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0,0,0,0.1);
      max-width: 500px;
      width: 100%;
      text-align: center;
    }
    
    h1 {
      color: #333;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #667eea, #764ba2);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      font-size: 1.8rem;
    }
    
    .subtitle { 
      color: #666; 
      margin-bottom: 25px;
      font-size: 1rem;
    }
    
    .name-section {
      margin-bottom: 20px;
      text-align: left;
    }
    
    .name-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }
    
    .name-input {
      width: 100%;
      padding: 12px 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      outline: none;
      margin-bottom: 15px;
    }
    
    .name-input:focus {
      border-color: #667eea;
    }
    
    .button-group {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-bottom: 25px;
    }
    
    button {
      padding: 15px 25px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s;
      min-height: 50px;
    }
    
    .create-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }
    
    .create-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
    }
    
    .join-section { 
      display: flex; 
      flex-direction: column;
      gap: 10px; 
    }
    
    @media (min-width: 480px) {
      .join-section {
        flex-direction: row;
      }
    }
    
    input {
      flex: 1;
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 10px;
      font-size: 16px;
      outline: none;
      min-height: 50px;
    }
    
    input:focus { border-color: #667eea; }
    
    .join-btn { 
      background: #2ecc71; 
      color: white; 
      min-width: 120px;
    }
    .join-btn:hover { background: #27ae60; }
    
    .room-info {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 10px;
      margin-top: 20px;
      display: none;
    }
    
    .call-controls { 
      margin-top: 20px; 
      display: none;
      text-align: center;
    }
    
    .call-status {
      padding: 15px;
      background: #d4edda;
      color: #155724;
      border-radius: 10px;
      margin-bottom: 20px;
      font-weight: 600;
    }
    
    .users-list {
      margin-top: 15px;
      text-align: left;
    }
    
    .user-item {
      padding: 10px 15px;
      margin: 8px 0;
      background: white;
      border-radius: 8px;
      border-left: 4px solid #667eea;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .user-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea, #764ba2);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: bold;
      font-size: 14px;
    }
    
    .user-name {
      font-weight: 600;
      color: #333;
    }
    
    .user-you {
      border-left-color: #2ecc71;
      background: #f8fff9;
    }
    
    .debug-info {
      margin-top: 10px;
      padding: 10px;
      background: #f8f9fa;
      border-radius: 8px;
      font-size: 12px;
      color: #666;
      text-align: left;
      max-height: 150px;
      overflow-y: auto;
    }
    
    .control-buttons {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .mute-btn, .leave-btn {
      padding: 12px 20px;
      font-size: 16px;
      border-radius: 25px;
      border: none;
      cursor: pointer;
      transition: all 0.3s;
      min-width: 120px;
    }
    
    .mute-btn {
      background: #6c757d;
      color: white;
    }
    
    .mute-btn.muted {
      background: #e74c3c;
    }
    
    .leave-btn {
      background: #dc3545;
      color: white;
    }
    
    .user-count { 
      font-weight: bold; 
      color: #667eea;
      font-size: 1.1rem;
    }
    
    .your-name {
      background: #667eea;
      color: white;
      padding: 8px 15px;
      border-radius: 20px;
      display: inline-block;
      margin: 10px 0;
      font-weight: 600;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¤ Real Voice Call</h1>
    <p class="subtitle">Create a room and start talking with WebRTC</p>
    
    <div class="name-section">
      <label class="name-label" for="userNameInput">Your Name:</label>
      <input type="text" id="userNameInput" class="name-input" placeholder="Enter your name" maxlength="20" value="">
    </div>
    
    <div class="button-group" id="setup">
      <button class="create-btn" onclick="createRoom()">Create New Room</button>
      <div class="join-section">
        <input type="text" id="roomInput" placeholder="Enter Room ID">
        <button class="join-btn" onclick="joinRoom()">Join Room</button>
      </div>
    </div>
    
    <div class="room-info" id="roomInfo">
      <h3>Room: <span id="roomIdDisplay"></span></h3>
      <div class="your-name">You are: <span id="userNameDisplay"></span></div>
      <p>Users in call: <span class="user-count" id="userCount">1</span></p>
      
      <div class="users-list" id="usersList">
        <!-- Users will be added here dynamically -->
      </div>
      
      <div class="debug-info" id="debugInfo">
        Connection status: Waiting...
      </div>
    </div>
    
    <div class="call-controls" id="callControls">
      <div class="call-status" id="callStatus">
        ðŸŽ¤ Setting up voice call...
      </div>
      
      <div class="control-buttons">
        <button class="mute-btn" id="muteButton" onclick="toggleMute()">
          ðŸ”‡ Mute
        </button>
        
        <button class="leave-btn" onclick="leaveRoom()">
          ðŸ“ž Leave Call
        </button>
      </div>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let localStream = null;
    let currentRoom = null;
    let isMuted = false;
    const peers = {};
    const remoteAudioElements = {};
    const config = { 
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' }
      ] 
    };

    // Debug logging
    function addDebug(message) {
      const debugInfo = document.getElementById('debugInfo');
      const timestamp = new Date().toLocaleTimeString();
      debugInfo.innerHTML += `<div>[${timestamp}] ${message}</div>`;
      debugInfo.scrollTop = debugInfo.scrollHeight;
      console.log(message);
    }

    // Check for room ID in URL
    const urlParams = new URLSearchParams(window.location.search);
    const roomFromUrl = urlParams.get('room');
    if (roomFromUrl) {
      document.getElementById('roomInput').value = roomFromUrl;
    }

    function getUserName() {
      const userNameInput = document.getElementById('userNameInput');
      return userNameInput.value.trim() || 'Anonymous';
    }

    function createRoom() {
      const userName = getUserName();
      addDebug('Creating room...');
      socket.emit('create-room', { userName });
    }

    function joinRoom() {
      const roomId = document.getElementById('roomInput').value.trim();
      const userName = getUserName();
      
      if (roomId) {
        addDebug('Joining room: ' + roomId);
        socket.emit('join-room', { roomId, userName });
      } else {
        alert('Please enter a room ID');
      }
    }

    function leaveRoom() {
      if (currentRoom) {
        addDebug('Leaving room...');
        socket.emit('leave-room', currentRoom);
        cleanup();
        resetUI();
      }
    }

    function toggleMute() {
      if (!localStream) return;
      
      isMuted = !isMuted;
      const muteButton = document.getElementById('muteButton');
      
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !isMuted;
      });
      
      if (isMuted) {
        muteButton.textContent = 'ðŸ”Š Unmute';
        muteButton.classList.add('muted');
        addDebug('Microphone muted');
      } else {
        muteButton.textContent = 'ðŸ”‡ Mute';
        muteButton.classList.remove('muted');
        addDebug('Microphone unmuted');
      }
    }

    async function setupLocalStream() {
      try {
        addDebug('Requesting microphone access...');
        localStream = await navigator.mediaDevices.getUserMedia({ 
          audio: {
            echoCancellation: true,
            noiseSuppression: true,
            autoGainControl: true
          },
          video: false
        });
        addDebug('Microphone access granted');
        return true;
      } catch (error) {
        addDebug('Error accessing microphone: ' + error.message);
        alert('Cannot access microphone. Please check permissions.');
        return false;
      }
    }

    function createPeerConnection(remoteId) {
      if (peers[remoteId]) {
        addDebug('Peer connection already exists for: ' + remoteId);
        return peers[remoteId];
      }

      addDebug('Creating peer connection for: ' + remoteId);
      const pc = new RTCPeerConnection(config);

      // Add local tracks
      if (localStream) {
        localStream.getTracks().forEach(track => {
          pc.addTrack(track, localStream);
        });
        addDebug('Added local tracks to peer: ' + remoteId);
      }

      // Create audio element for remote stream
      const audioElement = document.createElement('audio');
      audioElement.autoplay = true;
      audioElement.playsInline = true;
      audioElement.style.display = 'none';
      remoteAudioElements[remoteId] = audioElement;
      document.body.appendChild(audioElement);

      // Handle incoming tracks
      pc.ontrack = (event) => {
        addDebug('Received remote track from: ' + remoteId);
        if (event.streams && event.streams[0]) {
          audioElement.srcObject = event.streams[0];
          addDebug('Audio stream attached for: ' + remoteId);
        }
      };

      // Handle ICE candidates
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-ice-candidate', {
            to: remoteId,
            candidate: event.candidate
          });
        }
      };

      // Handle connection state changes
      pc.onconnectionstatechange = () => {
        addDebug(`Peer ${remoteId} connection state: ${pc.connectionState}`);
        if (pc.connectionState === 'connected') {
          document.getElementById('callStatus').textContent = 'âœ… Voice call connected - You can talk now!';
          document.getElementById('callStatus').style.background = '#d4edda';
          document.getElementById('callStatus').style.color = '#155724';
        }
      };

      peers[remoteId] = pc;
      return pc;
    }

    async function createOffer(remoteId) {
      const pc = createPeerConnection(remoteId);
      try {
        addDebug('Creating offer for: ' + remoteId);
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('webrtc-offer', {
          to: remoteId,
          sdp: pc.localDescription
        });
        addDebug('Offer sent to: ' + remoteId);
      } catch (error) {
        addDebug('Error creating offer: ' + error.message);
      }
    }

    async function handleOffer(from, sdp) {
      addDebug('Received offer from: ' + from);
      const pc = createPeerConnection(from);
      try {
        await pc.setRemoteDescription(sdp);
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('webrtc-answer', {
          to: from,
          sdp: pc.localDescription
        });
        addDebug('Answer sent to: ' + from);
      } catch (error) {
        addDebug('Error handling offer: ' + error.message);
      }
    }

    async function handleAnswer(from, sdp) {
      addDebug('Received answer from: ' + from);
      const pc = peers[from];
      if (pc) {
        try {
          await pc.setRemoteDescription(sdp);
          addDebug('Remote description set for: ' + from);
        } catch (error) {
          addDebug('Error handling answer: ' + error.message);
        }
      }
    }

    async function handleIceCandidate(from, candidate) {
      addDebug('Received ICE candidate from: ' + from);
      const pc = peers[from];
      if (pc) {
        try {
          await pc.addIceCandidate(candidate);
        } catch (error) {
          addDebug('Error adding ICE candidate: ' + error.message);
        }
      }
    }

    function cleanup() {
      // Close all peer connections
      Object.keys(peers).forEach(peerId => {
        peers[peerId].close();
        delete peers[peerId];
      });

      // Remove all audio elements
      Object.keys(remoteAudioElements).forEach(audioId => {
        if (remoteAudioElements[audioId].parentNode) {
          remoteAudioElements[audioId].parentNode.removeChild(remoteAudioElements[audioId]);
        }
        delete remoteAudioElements[audioId];
      });

      // Stop local stream
      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      addDebug('Cleaned up all connections');
    }

    // Socket event handlers
    socket.on('room-created', async (data) => {
      currentRoom = data.roomId;
      addDebug('Room created: ' + data.roomId);
      showRoomInfo(data.roomId, data.userName);
      
      // Setup local stream
      const success = await setupLocalStream();
      if (success) {
        document.getElementById('callStatus').textContent = 'âœ… Waiting for others to join...';
      }
    });

    socket.on('room-joined', async (data) => {
      currentRoom = data.roomId;
      addDebug('Room joined: ' + data.roomId + ' with ' + data.users.length + ' users');
      showRoomInfo(data.roomId, data.userName);
      updateUsersList(data.users);
      
      // Setup local stream
      const success = await setupLocalStream();
      if (success) {
        // Create offers to all existing users
        data.users.forEach(user => {
          if (user.id !== socket.id) {
            setTimeout(() => createOffer(user.id), 1000);
          }
        });
      }
    });

    socket.on('user-joined', (data) => {
      addDebug('User joined: ' + data.userName);
      addUserToList(data.userId, data.userName, false);
      updateUserCount();
      
      // Create offer to the new user
      if (localStream) {
        setTimeout(() => createOffer(data.userId), 1000);
      }
    });

    socket.on('user-left', (data) => {
      addDebug('User left: ' + data.userName);
      removeUserFromList(data.userId);
      updateUserCount();
      
      // Clean up peer connection
      if (peers[data.userId]) {
        peers[data.userId].close();
        delete peers[data.userId];
      }
      if (remoteAudioElements[data.userId]) {
        if (remoteAudioElements[data.userId].parentNode) {
          remoteAudioElements[data.userId].parentNode.removeChild(remoteAudioElements[data.userId]);
        }
        delete remoteAudioElements[data.userId];
      }
    });

    // WebRTC signaling
    socket.on('webrtc-offer', (data) => {
      handleOffer(data.from, data.sdp);
    });

    socket.on('webrtc-answer', (data) => {
      handleAnswer(data.from, data.sdp);
    });

    socket.on('webrtc-ice-candidate', (data) => {
      handleIceCandidate(data.from, data.candidate);
    });

    socket.on('error', (data) => {
      addDebug('Error: ' + data.message);
      alert('Error: ' + data.message);
    });

    function showRoomInfo(roomId, userName) {
      document.getElementById('setup').style.display = 'none';
      document.getElementById('roomInfo').style.display = 'block';
      document.getElementById('callControls').style.display = 'block';
      
      document.getElementById('roomIdDisplay').textContent = roomId;
      document.getElementById('userNameDisplay').textContent = userName;
    }

    function updateUsersList(users) {
      const usersList = document.getElementById('usersList');
      usersList.innerHTML = '';
      
      users.forEach(user => {
        const isCurrentUser = user.id === socket.id;
        addUserToList(user.id, user.name, isCurrentUser);
      });
      updateUserCount();
    }

    function addUserToList(userId, userName, isCurrentUser) {
      const usersList = document.getElementById('usersList');
      const userItem = document.createElement('div');
      userItem.className = 'user-item ' + (isCurrentUser ? 'user-you' : '');
      userItem.id = 'user-' + userId;
      
      const avatar = document.createElement('div');
      avatar.className = 'user-avatar';
      avatar.textContent = userName.charAt(0).toUpperCase();
      
      const name = document.createElement('div');
      name.className = 'user-name';
      name.textContent = userName + (isCurrentUser ? ' (You)' : '');
      
      userItem.appendChild(avatar);
      userItem.appendChild(name);
      usersList.appendChild(userItem);
    }

    function removeUserFromList(userId) {
      const userElement = document.getElementById('user-' + userId);
      if (userElement) {
        userElement.remove();
      }
    }

    function updateUserCount() {
      const userItems = document.querySelectorAll('.user-item');
      document.getElementById('userCount').textContent = userItems.length;
    }

    function resetUI() {
      document.getElementById('setup').style.display = 'block';
      document.getElementById('roomInfo').style.display = 'none';
      document.getElementById('callControls').style.display = 'none';
      currentRoom = null;
      document.getElementById('debugInfo').innerHTML = 'Connection status: Waiting...';
    }

    window.addEventListener('beforeunload', () => {
      if (currentRoom) {
        socket.emit('leave-room', currentRoom);
      }
    });

    // Focus on name input when page loads
    window.addEventListener('load', () => {
      document.getElementById('userNameInput').focus();
    });
  </script>
</body>
</html>