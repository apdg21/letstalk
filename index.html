<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Real Voice Call (WebRTC)</title>
  <style>
    /* Small UI so you can test easily */
    body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, Arial; display:flex; align-items:center; justify-content:center; min-height:100vh; background:linear-gradient(135deg,#667eea,#764ba2); }
    .card { background:white; padding:24px; border-radius:12px; width:360px; box-shadow:0 8px 30px rgba(0,0,0,0.12); text-align:center; }
    input, button { width:100%; padding:10px; margin:6px 0; border-radius:8px; border:1px solid #ddd; }
    .controls { margin-top:12px; display:none; }
    .users { text-align:left; margin-top:8px; max-height:120px; overflow:auto; }
    .user { padding:8px; border-radius:8px; background:#f6f9ff; margin-bottom:6px; }
  </style>
</head>
<body>
  <div class="card">
    <h2>ðŸŽ¤ Real Voice Call (WebRTC)</h2>
    <input id="userName" placeholder="Your name (optional)" />
    <button id="createBtn">Create Room</button>
    <input id="roomInput" placeholder="Room ID to join" />
    <button id="joinBtn">Join Room</button>

    <div class="controls" id="controls">
      <div>Room: <strong id="roomIdDisplay"></strong></div>
      <div class="users" id="usersList"></div>
      <button id="leaveBtn">Leave Room</button>
    </div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    const socket = io();
    let localStream = null;
    let currentRoom = null;
    const peers = {}; // remoteId -> RTCPeerConnection
    const remoteAudioEls = {}; // remoteId -> audio element
    const config = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };

    // UI
    const userNameInput = document.getElementById('userName');
    const createBtn = document.getElementById('createBtn');
    const joinBtn = document.getElementById('joinBtn');
    const roomInput = document.getElementById('roomInput');
    const controls = document.getElementById('controls');
    const roomIdDisplay = document.getElementById('roomIdDisplay');
    const usersList = document.getElementById('usersList');
    const leaveBtn = document.getElementById('leaveBtn');

    createBtn.onclick = () => {
      const name = userNameInput.value.trim() || 'Anonymous';
      socket.emit('create-room', { userName: name });
    };

    joinBtn.onclick = () => {
      const roomId = roomInput.value.trim();
      if (!roomId) return alert('Enter a room ID');
      const name = userNameInput.value.trim() || 'Anonymous';
      socket.emit('join-room', { roomId, userName: name });
    };

    leaveBtn.onclick = () => {
      if (!currentRoom) return;
      socket.emit('leave-room', currentRoom);
      cleanupAllPeers();
      currentRoom = null;
      controls.style.display = 'none';
      roomInput.value = '';
    };

    // Get microphone stream (called once when joining/creating)
    async function ensureLocalStream() {
      if (localStream) return localStream;
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true } });
        return localStream;
      } catch (err) {
        alert('Microphone access denied or unavailable: ' + err.message);
        throw err;
      }
    }

    function createPeerConnection(remoteId) {
      if (peers[remoteId]) return peers[remoteId];

      const pc = new RTCPeerConnection(config);

      // Add local tracks
      if (localStream) {
        for (const track of localStream.getTracks()) {
          pc.addTrack(track, localStream);
        }
      }

      // Create audio element for this remote
      const audioEl = document.createElement('audio');
      audioEl.autoplay = true;
      audioEl.playsInline = true;
      remoteAudioEls[remoteId] = audioEl;

      pc.ontrack = (ev) => {
        // attach the incoming stream to the audio element
        if (ev.streams && ev.streams[0]) {
          audioEl.srcObject = ev.streams[0];
        } else if (ev.track) {
          // fallback for some browsers
          const incomingStream = new MediaStream([ev.track]);
          audioEl.srcObject = incomingStream;
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit('webrtc-ice-candidate', { to: remoteId, candidate: event.candidate });
        }
      };

      pc.onconnectionstatechange = () => {
        if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed' || pc.connectionState === 'closed') {
          removePeer(remoteId);
        }
      };

      peers[remoteId] = pc;
      return pc;
    }

    async function makeOffer(remoteId) {
      const pc = createPeerConnection(remoteId);
      try {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('webrtc-offer', { to: remoteId, sdp: pc.localDescription });
      } catch (err) {
        console.error('Offer error', err);
      }
    }

    async function handleOffer(from, sdp) {
      await ensureLocalStream();
      const pc = createPeerConnection(from);
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('webrtc-answer', { to: from, sdp: pc.localDescription });
      } catch (err) {
        console.error('Handle offer error', err);
      }
    }

    async function handleAnswer(from, sdp) {
      const pc = peers[from];
      if (!pc) {
        console.warn('Answer from unknown peer', from);
        return;
      }
      await pc.setRemoteDescription(new RTCSessionDescription(sdp));
    }

    async function handleRemoteIce(from, candidate) {
      const pc = peers[from];
      if (!pc) return;
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        console.warn('Failed to add ICE candidate', err);
      }
    }

    function addRemoteUserToUI(id, name) {
      const el = document.createElement('div');
      el.id = 'user-' + id;
      el.className = 'user';
      el.textContent = (name || 'User') + (id === socket.id ? ' (You)' : '') + ' â€” ' + id;
      usersList.appendChild(el);
    }

    function removeRemoteUserFromUI(id) {
      const el = document.getElementById('user-' + id);
      if (el) el.remove();
    }

    function attachRemoteAudioToUI(remoteId) {
      // append audio element to users list so it can autoplay with a user gesture
      const audioEl = remoteAudioEls[remoteId];
      if (!audioEl) return;
      const userDiv = document.getElementById('user-' + remoteId);
      if (userDiv && !userDiv.contains(audioEl)) {
        userDiv.appendChild(audioEl);
      }
    }

    function removePeer(remoteId) {
      const pc = peers[remoteId];
      if (pc) {
        try { pc.close(); } catch (e) {}
        delete peers[remoteId];
      }
      const audioEl = remoteAudioEls[remoteId];
      if (audioEl) {
        try { audioEl.srcObject = null; } catch (e) {}
        if (audioEl.parentNode) audioEl.parentNode.removeChild(audioEl);
        delete remoteAudioEls[remoteId];
      }
      removeRemoteUserFromUI(remoteId);
    }

    function cleanupAllPeers() {
      for (const id of Object.keys(peers)) {
        removePeer(id);
      }
      usersList.innerHTML = '';
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
    }

    // Socket events
    socket.on('room-created', async (data) => {
      currentRoom = data.roomId;
      roomIdDisplay.textContent = currentRoom;
      controls.style.display = 'block';
      usersList.innerHTML = '';
      addRemoteUserToUI(socket.id, data.userName || 'You');

      // get microphone ready for when others join
      await ensureLocalStream();
      // (no peers yet)
    });

    socket.on('room-joined', async (data) => {
      currentRoom = data.roomId;
      roomIdDisplay.textContent = currentRoom;
      controls.style.display = 'block';
      usersList.innerHTML = '';

      // ensure local audio stream first
      await ensureLocalStream();

      // Add all users in room to UI
      const users = data.users || [];
      for (const u of users) {
        addRemoteUserToUI(u.id, u.name);
      }

      // For each other user, create an offer to them
      for (const u of users) {
        if (u.id === socket.id) continue;
        // create audio element placeholder and then makeOffer
        createPeerConnection(u.id);
        attachRemoteAudioToUI(u.id);
        makeOffer(u.id);
      }
    });

    socket.on('user-joined', async (data) => {
      const { userId, userName } = data;
      addRemoteUserToUI(userId, userName);
      // existing clients should initiate offer to the newcomer
      createPeerConnection(userId);
      attachRemoteAudioToUI(userId);
      // small delay to ensure new user is ready
      setTimeout(() => {
        makeOffer(userId);
      }, 250);
    });

    socket.on('user-left', (data) => {
      const { userId } = data;
      removePeer(userId);
    });

    // WebRTC signaling message handlers
    socket.on('webrtc-offer', async (data) => {
      const { from, sdp } = data;
      await ensureLocalStream();
      handleOffer(from, sdp);
      // Attach audio element (UI)
      addRemoteUserToUI(from, 'Remote');
      attachRemoteAudioToUI(from);
    });

    socket.on('webrtc-answer', async (data) => {
      const { from, sdp } = data;
      await handleAnswer(from, sdp);
      attachRemoteAudioToUI(from);
    });

    socket.on('webrtc-ice-candidate', async (data) => {
      const { from, candidate } = data;
      await handleRemoteIce(from, candidate);
    });

    // optional legacy audio handler (if you keep it)
    socket.on('audio', (data) => {
      console.log('legacy audio event received (ignored in WebRTC flow).');
    });

    window.addEventListener('beforeunload', () => {
      if (currentRoom) {
        socket.emit('leave-room', currentRoom);
      }
    });
  </script>
</body>
</html>
